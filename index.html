<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Palette Collage — Accidental Art Generator</title>
<style>
  :root{
    --bg:#0e0f12;
    --fg:#e9eef3;
    --muted:#9aa3ad;
    --accent:#58d0ff;
    --accent-2:#8aff8a;
    --panel:#151820;
    --panel-2:#1a1f2a;
    --ring: rgba(88,208,255,.5);
    --shadow: 0 10px 30px rgba(0,0,0,.35);
  }

  html, body {
    margin:0; padding:0; height:100%;
    background: radial-gradient(1200px 700px at 10% 0%, #141822 0%, #0d1016 60%, #0b0d12 100%);
    color: var(--fg);
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif;
  }

  /* Canvas fills the window */
  #stage {
    position: fixed;
    inset: 0;
    width: 100vw;
    height: 100vh;
    display:block;
    cursor: crosshair;
  }

  /* Top control bar */
  .chrome {
    position: fixed; inset: 16px 16px auto 16px;
    display:flex; gap:10px; align-items:center;
    background: linear-gradient(180deg, rgba(21,25,34,.9), rgba(21,25,34,.75));
    border: 1px solid #2a3342;
    border-radius: 14px;
    padding: 10px 12px;
    box-shadow: var(--shadow);
    backdrop-filter: blur(6px);
    z-index: 10;
    user-select: none;
  }

  .chrome h1 {
    font-size: 14px; margin:0 8px 0 2px; letter-spacing:.4px; color:#dfe7ee; font-weight:600;
  }

  .spacer { flex: 1; }

  .btn, .select {
    appearance: none;
    background: var(--panel-2);
    color: var(--fg);
    border: 1px solid #2b3443;
    padding: 8px 12px;
    border-radius: 12px;
    font-size: 13px;
    line-height: 1;
    box-shadow: inset 0 0 0 1px rgba(255,255,255,.02);
  }
  .btn:hover, .select:hover { border-color:#3a475d; }
  .btn:active { transform: translateY(1px); }

  .btn.primary {
    background: linear-gradient(180deg, #1d2736, #182233);
    border-color: #334259;
  }
  .btn.glow {
    box-shadow: 0 0 0 2px var(--ring);
  }

  label.file {
    position: relative; overflow: hidden; cursor: pointer; display:inline-flex; align-items:center; gap:8px;
  }
  label.file input { position:absolute; inset:0; opacity:0; cursor:pointer; }

  .hint {
    font-size:12px; color: var(--muted);
    padding: 2px 8px;
    border-left: 1px solid #2a3342;
    margin-left: 6px;
  }

  /* Bottom palette panel */
  .palette {
    position: fixed; inset: auto 16px 16px 16px;
    display:flex; gap:10px; align-items:stretch;
    background: linear-gradient(180deg, rgba(21,25,34,.88), rgba(21,25,34,.72));
    border: 1px solid #2a3342;
    border-radius: 14px;
    padding: 10px;
    box-shadow: var(--shadow);
    backdrop-filter: blur(6px);
    z-index: 9;
    min-height: 64px;
  }
  .swatch {
    position: relative; width: 56px; border-radius: 10px; overflow: hidden; border:1px solid rgba(255,255,255,.08);
  }
  .swatch span {
    position:absolute; bottom:6px; left:6px; right:6px;
    font-size:11px; text-shadow: 0 1px 2px rgba(0,0,0,.6);
  }

  /* Drop / Paste overlay */
  .overlay {
    position: fixed; inset:0; display:none;
    align-items:center; justify-content:center; flex-direction:column;
    background: radial-gradient(600px 300px at 50% 40%, rgba(88,208,255,.10), rgba(0,0,0,.6));
    border: 2px dashed rgba(88,208,255,.35);
    pointer-events:none;
    z-index: 100;
  }
  .overlay.show { display:flex; animation: pulse 1.2s infinite ease-in-out; }
  .overlay .big {
    font-size: 28px; font-weight:700; letter-spacing:.5px; color:#e9f6ff;
    text-shadow: 0 8px 24px rgba(88,208,255,.35);
    margin-bottom:8px;
  }
  .overlay .small { color:#b9d8e6; font-size:14px; }

  @keyframes pulse {
    0% { box-shadow: inset 0 0 0 0 rgba(88,208,255,.25); }
    50% { box-shadow: inset 0 0 0 8px rgba(88,208,255,.15); }
    100% { box-shadow: inset 0 0 0 0 rgba(88,208,255,.25); }
  }

  /* Toast */
  .toast {
    position: fixed; left: 50%; transform: translateX(-50%);
    bottom: 96px; padding: 10px 14px; border-radius: 12px; font-size: 13px;
    background: #10151e; color:#e8f2ff; border:1px solid #2b3443; box-shadow: var(--shadow);
    opacity: 0; pointer-events:none; transition: opacity .25s ease;
    z-index: 20;
  }
  .toast.show { opacity: 1; }

  /* Help */
  .kbd {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    font-size: 12px;
    background:#0b0f15; border:1px solid #2a3342; padding:2px 6px; border-radius:6px; color:#cfe7ff;
  }

  /* Hide file input when JS disabled fallback shows text */
  noscript { position: fixed; top:0; left:0; right:0; background:#b00020; color:white; padding:8px; text-align:center; z-index:999; }
</style>
</head>
<body>
<canvas id="stage" aria-label="Artwork canvas"></canvas>

<div class="chrome" role="region" aria-label="Controls">
  <h1>Palette Collage</h1>
  <button class="btn" id="openBtn" title="Open image (O)">Open Image</button>
  <label class="btn file" title="Upload file">
    <input id="fileInput" type="file" accept="image/*" />
    Choose File
  </label>

  <select id="mode" class="select" title="Render mode (1/2/3...)">
    <option value="stripes">Stripes (kinetic)</option> 
    <option value="blobs">Blobs (soft)</option>
    <option value="shards">Shards (geometric)</option>
    <option value="bauhaus">Bauhaus Grid Composition</option> 
    <option value="diagonal">Diagonal Lines</option>
    <option value="pixel" selected>Pixel Weave (Texture)</option>
    <option value="contour">Contour Lines (Topographical)</option>
    <option value="glass">Stained Glass (Tessellation)</option>
    <option value="wave">Wave Collapse (Horizontal Flow)</option>
    <option value="halftone">Halftone Grid (Density)</option>
    <option value="rectilinear">Rectilinear Stack (Architectural)</option>
    <option value="neon">Neon Glow (Minimalist Light)</option>
    <option value="tracer">Field Tracer (Flow) - UNIQUE</option>
    <option value="fractal">Recursive Fractal Growth - UNIQUE</option>
    <option value="woven">Woven Tessellation (Interlocked) - UNIQUE</option>
  </select>

  <button class="btn primary" id="shuffleBtn" title="Repaint (Space)">Shuffle</button>
  <button class="btn" id="exportBtn" title="Export PNG (E)">Export PNG</button>
  <button class="btn" id="copyBtn" title="Copy HEX palette (C)">Copy Palette</button>

  <span class="spacer"></span>
  <span class="hint">
    Drop / paste an image • <span class="kbd">Space</span> shuffle
    • Modes <span class="kbd">1</span>-<span class="kbd">9</span>, <span class="kbd">0</span>, <span class="kbd">Q</span>, <span class="kbd">W</span>, <span class="kbd">R</span>, <span class="kbd">T</span>, <span class="kbd">Y</span>
  </span>
</div>

<div class="palette" id="palette" aria-label="Extracted palette"></div>

<div class="overlay" id="overlay" aria-hidden="true">
  <div class="big">Drop or Paste an Image</div>
  <div class="small">We’ll turn its colors into accidental art — locally, no uploads.</div>
</div>

<div class="toast" id="toast" role="status" aria-live="polite"></div>

<noscript>This app needs JavaScript enabled.</noscript>

<script>
(() => {
  const canvas = document.getElementById('stage');
  const ctx = canvas.getContext('2d', { willReadFrequently:true }); // for color sampling perf
  const overlay = document.getElementById('overlay');
  const toast = document.getElementById('toast');
  const paletteEl = document.getElementById('palette');
  const fileInput = document.getElementById('fileInput');
  const openBtn = document.getElementById('openBtn');
  const shuffleBtn = document.getElementById('shuffleBtn');
  const exportBtn = document.getElementById('exportBtn');
  const copyBtn   = document.getElementById('copyBtn');
  const modeSel   = document.getElementById('mode');

  let currentImageBitmap = null;
  let currentPalette = ['#2f2f2f','#6b6b6b','#9a9a9a','#c5c5c5','#efefef'];
  let rngSeed = Math.random() * 1e9;

  // Resize canvas to full window
  function fit() {
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    canvas.width  = Math.floor(innerWidth  * dpr);
    canvas.height = Math.floor(innerHeight * dpr);
    canvas.style.width  = innerWidth + 'px';
    canvas.style.height = innerHeight + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    repaint();
  }
  window.addEventListener('resize', fit, { passive:true });
  fit();

  function showToast(msg, ms=1400){
    toast.textContent = msg;
    toast.classList.add('show');
    setTimeout(() => toast.classList.remove('show'), ms);
  }

  // Lightweight seeded RNG for consistent shuffles
  function mulberry32(a){
    return function(){
      let t = a += 0x6D2B79F5;
      t = Math.imul(t ^ t >>> 15, t | 1);
      t ^= t + Math.imul(t ^ t >>> 7, t | 61);
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    }
  }

  // Palette extraction using mini k-means clustering (fully client-side)
  async function extractPaletteFromImageBitmap(bmp, k=5, down=80, iters=10){
    // Draw to a small temp canvas for sampling
    const t = document.createElement('canvas');
    const tw = down, th = Math.max(1, Math.round(down * (bmp.height / bmp.width)));
    t.width = tw; t.height = th;
    const tctx = t.getContext('2d', { willReadFrequently:true });
    tctx.drawImage(bmp, 0, 0, tw, th);
    const { data } = tctx.getImageData(0, 0, tw, th);

    // Collect RGB samples (skip fully transparent)
    const samples = [];
    for (let i = 0; i < data.length; i += 4) {
      const a = data[i+3];
      if (a < 8) continue;
      const r = data[i], g = data[i+1], b = data[i+2];
      // Slight gamma-ish shaping to favor midtones
      samples.push([r, g, b]);
    }
    if (samples.length === 0) return ['#666','#888','#aaa','#ccc','#eee'];

    // Init centroids by random samples
    const rand = mulberry32(Math.floor(Math.random()*1e9));
    const centroids = [];
    for (let i = 0; i < k; i++){
      const s = samples[Math.floor(rand() * samples.length)];
      centroids.push(s.slice());
    }

    // K-means iterations
    for (let it = 0; it < iters; it++){
      const buckets = Array.from({length:k}, () => ({sum:[0,0,0], n:0}));
      for (let s of samples){
        let bi=0, bd=Infinity;
        for (let ci=0; ci<k; ci++){
          const c = centroids[ci];
          // Euclidean distance in RGB
          const dr=s[0]-c[0], dg=s[1]-c[1], db=s[2]-c[2];
          const d = dr*dr + dg*dg + db*db;
          if (d < bd){ bd=d; bi=ci; }
        }
        const b = buckets[bi];
        b.sum[0]+=s[0]; b.sum[1]+=s[1]; b.sum[2]+=s[2]; b.n++;
      }
      // Recompute centroids
      for (let ci=0; ci<k; ci++){
        const b = buckets[ci];
        if (b.n){
          centroids[ci][0] = b.sum[0]/b.n;
          centroids[ci][1] = b.sum[1]/b.n;
          centroids[ci][2] = b.sum[2]/b.n;
        } else {
          // re-seed empty cluster
          const s = samples[Math.floor(rand()*samples.length)];
          centroids[ci] = s.slice();
        }
      }
    }

    // Sort by “perceptual brightness” to get a nice order
    const hex = centroids
      .map(c => ({
        c,
        l: 0.2126*c[0] + 0.7152*c[1] + 0.0722*c[2]
      }))
      .sort((a,b) => a.l - b.l)
      .map(o => rgbToHex(o.c[0], o.c[1], o.c[2]));

    return uniqueish(hex);
  }

  function uniqueish(list){
    // De-duplicate near-duplicates by collapsing similar hexes
    const out = [];
    for (const h of list){
      const [r,g,b] = hexToRgb(h);
      let keep = true;
      for (const oh of out){
        const [or,og,ob] = hexToRgb(oh);
        const d = (r-or)**2 + (g-og)**2 + (b-ob)**2;
        if (d < 400) { keep=false; break; } // ~20 delta
      }
      if (keep) out.push(h);
    }
    // Ensure at least 5 by adding jittered variants if needed
    while (out.length < 5){
      const base = out[out.length-1] || '#888888';
      out.push(jitterHex(base, 10));
    }
    return out.slice(0,5);
  }

  function jitterHex(h, amt=12){
    const [r,g,b] = hexToRgb(h);
    const j = (v)=>Math.max(0, Math.min(255, v + (Math.random()*2-1)*amt|0));
    return rgbToHex(j(r), j(g), j(b));
  }

  function rgbToHex(r,g,b){
    r=Math.round(r); g=Math.round(g); b=Math.round(b);
    return '#' + [r,g,b].map(v => v.toString(16).padStart(2,'0')).join('');
  }
  function hexToRgb(h){
    const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(h);
    if(!m) return [128,128,128];
    return [parseInt(m[1],16), parseInt(m[2],16), parseInt(m[3],16)];
  }

  // ---- Rendering modes -----------------------------------------------------

  function repaint(){
    // if nothing loaded yet, paint a subtle backdrop
    if (!currentImageBitmap){
      paintBackdrop();
    }
    const mode = modeSel.value;
    const seeded = mulberry32(Math.floor(rngSeed));
    
    // Clear the canvas explicitly for modes that don't call paintBackdrop() first
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if (mode === 'blobs') paintBlobs(currentPalette, seeded);
    else if (mode === 'shards') paintShards(currentPalette, seeded);
    else if (mode === 'bauhaus') paintBauhausGrid(currentPalette, seeded);
    
    // STANDARD MODES
    else if (mode === 'pixel') paintPixelWeave(currentPalette, seeded);
    else if (mode === 'contour') paintContourLines(currentPalette, seeded);
    else if (mode === 'glass') paintStainedGlass(currentPalette, seeded);
    else if (mode === 'wave') paintWaveCollapse(currentPalette, seeded);
    else if (mode === 'halftone') paintHalftoneGrid(currentPalette, seeded);
    else if (mode === 'rectilinear') paintRectilinearStack(currentPalette, seeded);
    else if (mode === 'neon') paintNeonGlow(currentPalette, seeded);
    
    // UNIQUE MODES
    else if (mode === 'tracer') paintFieldTracer(currentPalette, seeded);
    else if (mode === 'fractal') paintRecursiveFractalGrowth(currentPalette, seeded);
    else if (mode === 'woven') paintWovenTessellation(currentPalette, seeded);
    
    else if (mode === 'diagonal') paintDiagonalLines(currentPalette, seeded); // New default/selected value
    else paintStripes(currentPalette, seeded); // Fallback

    addGrainOverlay(0.07, seeded); // subtle film grain to unify
    drawSignature();
    drawPaletteBar(currentPalette);
  }

  function paintBackdrop(){
    const g = ctx.createLinearGradient(0,0,0,canvas.height);
    g.addColorStop(0, '#0d1016');
    g.addColorStop(1, '#0a0c10');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,canvas.width,canvas.height);
  }

  function paintBlobs(colors, rand){
    paintBackdrop();
    const W = canvas.width, H = canvas.height;
    const count = 220;
    for (let i=0; i<count; i++){
      const c = colors[Math.floor(rand()*colors.length)];
      const [r,g,b] = hexToRgb(c);
      const x = rand()*W, y = rand()*H;
      const radius = 60 + rand()*260;
      const grad = ctx.createRadialGradient(x, y, 0, x, y, radius);
      const a = 0.08 + rand()*0.22;
      grad.addColorStop(0, `rgba(${r},${g},${b},${a*1.2})`);
      grad.addColorStop(1, `rgba(${r},${g},${b},0)`);
      ctx.globalCompositeOperation = (rand() < 0.5) ? 'lighter' : 'source-over';
      ctx.fillStyle = grad;
      ctx.beginPath(); ctx.arc(x, y, radius, 0, Math.PI*2); ctx.fill();
    }
    ctx.globalCompositeOperation = 'source-over';
  }

  function paintShards(colors, rand){
    paintBackdrop();
    const W = canvas.width, H = canvas.height;
    const layers = 90;
    for (let i=0; i<layers; i++){
      const c = colors[Math.floor(rand()*colors.length)];
      ctx.fillStyle = c;
      ctx.globalAlpha = 0.18 + rand()*0.5;
      const cx = (rand()*W);
      const cy = (rand()*H);
      const n = 3 + Math.floor(rand()*4); // triangles to hex-ish
      const size = 80 + rand()*420;
      ctx.beginPath();
      for (let j=0; j<n; j++){
        const a = rand()*Math.PI*2;
        const r = size * (.4 + rand());
        const x = cx + Math.cos(a)*r;
        const y = cy + Math.sin(a)*r;
        (j===0) ? ctx.moveTo(x,y) : ctx.lineTo(x,y);
      }
      ctx.closePath();
      ctx.filter = (rand()<0.35) ? 'blur(1px)' : 'none';
      ctx.fill();
    }
    ctx.filter = 'none';
    ctx.globalAlpha = 1;
  }

  function paintStripes(colors, rand){
    paintBackdrop();
    const W = canvas.width, H = canvas.height;
    const bands = 46;
    for (let i=0; i<bands; i++){
      const c = colors[Math.floor(rand()*colors.length)];
      ctx.fillStyle = c;
      ctx.globalAlpha = 0.15 + rand()*0.55;
      const thick = 10 + rand()*120;
      const x = rand()*W, y = rand()*H;
      const len = Math.max(W,H) * (0.7 + rand()*0.8);
      const angle = rand()*Math.PI*2;

      ctx.save();
      ctx.translate(x,y);
      ctx.rotate(angle);
      ctx.fillRect(-len/2, -thick/2, len, thick);
      ctx.restore();
    }
    ctx.globalAlpha = 1;
  }

  function paintBauhausGrid(colors, rand) {
      const W = canvas.width, H = canvas.height;
      const BG_COLOR = '#FFFFFF'; 

      ctx.fillStyle = BG_COLOR;
      ctx.fillRect(0, 0, W, H);
      ctx.globalAlpha = 1.0; 

      const GRID_SIZE = 4;
      const CELL_W = W / GRID_SIZE;
      const CELL_H = H / GRID_SIZE;
      
      const filledCells = new Set();
      const MAX_FILL = Math.floor(GRID_SIZE * GRID_SIZE * 0.55); 
      let cellIndex = 0;

      for (let row = 0; row < GRID_SIZE; row++) {
          for (let col = 0; col < GRID_SIZE; col++) {
              
              if (rand() < 0.55 && filledCells.size < MAX_FILL) {
                  filledCells.add(cellIndex);
                  
                  const centerX = col * CELL_W + CELL_W / 2;
                  const centerY = row * CELL_H + CELL_H / 2;
                  
                  const colorIndex = Math.floor(rand() * 2); 
                  const accentColorIndex = Math.floor(rand() * (colors.length - 2)) + 2; 

                  // --- 1. Draw the Main Block (Large Shape) ---
                  const largeColor = rgbToHex(...hexToRgb(colors[colorIndex]));
                  ctx.fillStyle = largeColor;
                  
                  const blockW = CELL_W * (rand() * 0.15 + 0.80); 
                  const blockH = CELL_H * (rand() * 0.15 + 0.80);
                  
                  ctx.fillRect(centerX - blockW / 2, centerY - blockH / 2, blockW, blockH);

                  // --- 2. Optional Overlap/Accent Layer ---
                  if (rand() < 0.4) { 
                      const accentColor = rgbToHex(...hexToRgb(colors[accentColorIndex]));
                      
                      ctx.fillStyle = accentColor;
                      ctx.globalAlpha = 0.9;
                      
                      if (rand() > 0.5) { 
                          const lineH = CELL_H * 0.05;
                          const lineW = blockW * 0.8;
                          ctx.fillRect(centerX - lineW / 2, centerY - lineH / 2, lineW, lineH);
                      } else {
                          const lineW = CELL_W * 0.05;
                          const lineH = blockH * 0.8;
                          ctx.fillRect(centerX - lineW / 2, centerY - lineH / 2, lineW, lineH);
                      }
                  }
                  ctx.globalAlpha = 1.0; 
              }
              cellIndex++;
          }
      }
  }

  function paintDiagonalLines(colors, rand) {
      const W = canvas.width, H = canvas.height;
      ctx.fillStyle = '#FFFFFF'; 
      ctx.fillRect(0, 0, W, H);
      ctx.globalAlpha = 1.0; 

      const space = 40; 
      let x = -H; 
      
      while (x < W + H) {
          const color = rgbToHex(...hexToRgb(colors[Math.floor(rand() * colors.length)]));
          ctx.fillStyle = color;
          ctx.globalAlpha = rand() * 0.4 + 0.5; 

          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x + space * 1.5, 0); 
          ctx.lineTo(W, H - (x + space * 1.5 - W));
          ctx.lineTo(W, H - (x - W));
          ctx.closePath();
          ctx.fill();

          x += space;
      }
      ctx.globalAlpha = 1.0; 
  }
  
  // --- UPDATED STYLE: Pixel Weave (Woven Texture) ---
  function paintPixelWeave(colors, rand) {
      const W = canvas.width, H = canvas.height;
      const RESOLUTION = 48; 
      const CELL_W = W / RESOLUTION;
      const CELL_H = H / RESOLUTION;
      const STRIP_THICKNESS = 4;

      // 1. Fully randomized background (was colors[0])
      const bgColor = colors[Math.floor(rand() * colors.length)];
      ctx.fillStyle = bgColor; 
      ctx.fillRect(0, 0, W, H);
      ctx.globalAlpha = 1.0;

      for (let x = 0; x < RESOLUTION; x++) {
          for (let y = 0; y < RESOLUTION; y++) {
              
              const px = x * CELL_W;
              const py = y * CELL_H;
              
              // 2. Draw base square pixel (for underlying color/texture)
              const baseColor = colors[Math.floor(rand() * colors.length)];
              ctx.fillStyle = baseColor;
              ctx.globalAlpha = 0.15 + rand() * 0.15; // Increased randomization here
              ctx.fillRect(px, py, CELL_W, CELL_H);
              
              // 3. Draw a horizontal strip (fully random color)
              const colorH = colors[Math.floor(rand() * colors.length)];
              ctx.fillStyle = colorH;
              ctx.globalAlpha = 0.5 + rand() * 0.4;
              const hOffset = CELL_H * (0.3 + rand() * 0.4) - STRIP_THICKNESS/2;
              ctx.fillRect(px, py + hOffset, CELL_W, STRIP_THICKNESS);
              
              // 4. Draw a vertical strip (fully random color)
              const colorV = colors[Math.floor(rand() * colors.length)];
              ctx.fillStyle = colorV;
              ctx.globalAlpha = 0.5 + rand() * 0.4;
              const vOffset = CELL_W * (0.3 + rand() * 0.4) - STRIP_THICKNESS/2;
              ctx.fillRect(px + vOffset, py, STRIP_THICKNESS, CELL_H);
          }
      }
      ctx.globalAlpha = 1.0;
  }
  
  // --- NEW STYLE: Contour Lines (Topographical) ---
  function paintContourLines(colors, rand) {
      paintBackdrop();
      const W = canvas.width, H = canvas.height;
      const lineCount = 120;
      
      ctx.lineWidth = 1 + rand() * 2;
      ctx.globalAlpha = 0.15;
      
      for (let i = 0; i < lineCount; i++) {
          const c = colors[Math.floor(rand() * colors.length)];
          ctx.strokeStyle = c;
          
          // Random starting points
          const startX = rand() * W;
          const startY = rand() * H;
          
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          
          // Use quadratic curves to create organic wobble
          const segments = 4 + Math.floor(rand() * 4);
          let currentX = startX;
          let currentY = startY;
          
          for (let j = 0; j < segments; j++) {
              const cpX = currentX + (rand() * 0.5 + 0.5) * (rand() < 0.5 ? -1 : 1) * 150;
              const cpY = currentY + (rand() * 0.5 + 0.5) * (rand() < 0.5 ? -1 : 1) * 150;
              
              currentX += (rand() * 0.5 + 0.5) * 200 * (rand() < 0.5 ? -1 : 1);
              currentY += (rand() * 0.5 + 0.5) * 200 * (rand() < 0.5 ? -1 : 1);
              
              ctx.quadraticCurveTo(cpX, cpY, currentX, currentY);
          }
          ctx.stroke();
      }
      ctx.globalAlpha = 1.0;
  }
  
  // --- NEW STYLE: Stained Glass (Irregular Tessellation) ---
  function paintStainedGlass(colors, rand) {
      const W = canvas.width, H = canvas.height;
      const GRID_SIZE = 4;
      const DENSITY = 6;
      
      ctx.fillStyle = '#111111'; // Dark background for the lead lines
      ctx.fillRect(0, 0, W, H);
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#222222';
      
      // Generate random points in a slightly organized grid structure
      const points = [];
      const cellW = W / GRID_SIZE;
      const cellH = H / GRID_SIZE;

      for (let r = 0; r <= GRID_SIZE; r++) {
          for (let c = 0; c <= GRID_SIZE; c++) {
              for (let i = 0; i < DENSITY; i++) {
                  const x = c * cellW + rand() * cellW;
                  const y = r * cellH + rand() * cellH;
                  points.push({x, y});
              }
          }
      }

      // Simple, non-Voronoi random tessellation based on points
      const triangles = [];
      while(points.length >= 3) {
          const i1 = Math.floor(rand() * points.length);
          const p1 = points.splice(i1, 1)[0];
          
          const i2 = Math.floor(rand() * points.length);
          const p2 = points.splice(i2, 1)[0];
          
          const i3 = Math.floor(rand() * points.length);
          const p3 = points.splice(i3, 1)[0];

          if(p1 && p2 && p3) triangles.push([p1, p2, p3]);
      }
      
      // Draw the "glass"
      triangles.forEach(poly => {
          const color = colors[Math.floor(rand() * colors.length)];
          ctx.fillStyle = color;
          ctx.globalAlpha = 0.95;
          
          ctx.beginPath();
          ctx.moveTo(poly[0].x, poly[0].y);
          ctx.lineTo(poly[1].x, poly[1].y);
          ctx.lineTo(poly[2].x, poly[2].y);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
      });
      ctx.globalAlpha = 1.0;
  }

  // --- NEW STYLE: Wave Collapse (Horizontal Flow) ---
  function paintWaveCollapse(colors, rand) {
      const W = canvas.width, H = canvas.height;
      const bandHeight = 40 + rand() * 100;
      let y = 0;

      while (y < H) {
          const h = bandHeight * (0.8 + rand() * 0.4);
          const color1 = colors[Math.floor(rand() * colors.length)];
          const color2 = colors[Math.floor(rand() * colors.length)];
          
          const grad = ctx.createLinearGradient(0, y, 0, y + h);
          grad.addColorStop(0, color1);
          // Mid-point color bleed/merge
          grad.addColorStop(0.5 + (rand() * 0.2 - 0.1), color1);
          grad.addColorStop(0.5, color2);
          grad.addColorStop(1, color2);
          
          ctx.fillStyle = grad;
          ctx.globalAlpha = 0.8 + rand() * 0.2;
          ctx.fillRect(0, y, W, h);
          
          // Introduce noise/wave effect
          ctx.globalAlpha = 0.05;
          ctx.fillStyle = '#000000';
          for(let i=0; i<W; i+=20) {
              const waveY = Math.sin((i / W * 2 * Math.PI) + (rand() * 10)) * 5 * rand();
              ctx.fillRect(i, y + h/2 + waveY, 5, h);
          }
          
          y += h * (0.5 + rand() * 0.5); // Overlapping
      }
      ctx.globalAlpha = 1.0;
  }

  // --- NEW STYLE: Halftone Grid (Density) ---
  function paintHalftoneGrid(colors, rand) {
      paintBackdrop();
      const W = canvas.width, H = canvas.height;
      const RESOLUTION = 40;
      const step = W / RESOLUTION;

      for (let x = 0; x < W; x += step) {
          for (let y = 0; y < H; y += step) {
              const color = colors[Math.floor(rand() * colors.length)];
              const [r, g, b] = hexToRgb(color);
              
              // Calculate perceived luminance (0-255)
              const L = (0.2126*r + 0.7152*g + 0.0722*b); 
              
              // Map luminance to a radius (Inverse relationship for halftone: bright -> small dot)
              // Radius is between 10% and 90% of the step size.
              const maxR = step * 0.45;
              const radius = maxR * (1 - L / 255); 
              
              ctx.fillStyle = color;
              ctx.globalAlpha = 0.9;
              
              ctx.beginPath();
              ctx.arc(x + step / 2, y + step / 2, radius, 0, Math.PI * 2);
              ctx.fill();
          }
      }
      ctx.globalAlpha = 1.0;
  }
  
  // --- NEW STYLE: Rectilinear Stack (Architectural) ---
  function paintRectilinearStack(colors, rand) {
      const W = canvas.width, H = canvas.height;
      const count = 100;

      ctx.fillStyle = '#FFFFFF';
      ctx.fillRect(0, 0, W, H);
      ctx.globalAlpha = 1.0;

      for (let i = 0; i < count; i++) {
          const color = colors[Math.floor(rand() * colors.length)];
          ctx.fillStyle = color;
          
          // Use less opaque alpha for depth/overlap effect
          ctx.globalAlpha = 0.2 + rand() * 0.6; 

          const x = rand() * W * 1.5 - W * 0.25;
          const y = rand() * H * 1.5 - H * 0.25;
          const w = 50 + rand() * 300;
          const h = 50 + rand() * 300;
          
          ctx.fillRect(x, y, w, h);
          
          // Optional thin black stroke for definition
          if (rand() < 0.2) {
              ctx.strokeStyle = '#000000';
              ctx.globalAlpha = 0.1;
              ctx.strokeRect(x, y, w, h);
          }
      }
      ctx.globalAlpha = 1.0;
  }
  
  // --- NEW STYLE: Neon Glow (Minimalist Light) ---
  function paintNeonGlow(colors, rand) {
      const W = canvas.width, H = canvas.height;
      
      // Start with a dark/black background
      ctx.fillStyle = '#0a0c10'; 
      ctx.fillRect(0, 0, W, H);
      
      ctx.lineWidth = 4 + rand() * 3;
      ctx.globalCompositeOperation = 'lighter'; // Use 'lighter' for glow/additive effect
      
      const glowCount = 20;

      for (let i = 0; i < glowCount; i++) {
          const c = colors[Math.floor(rand() * (colors.length - 1)) + 1]; // Avoid black/darkest color
          ctx.strokeStyle = c;
          ctx.globalAlpha = 0.8;
          ctx.filter = `blur(${8 + rand() * 12}px)`; // Apply heavy blur for glow
          
          // Simple geometric shapes: lines and circles
          if (rand() < 0.5) { 
              // Line
              ctx.beginPath();
              ctx.moveTo(rand() * W, rand() * H);
              ctx.lineTo(rand() * W, rand() * H);
              ctx.stroke();
          } else { 
              // Circle
              ctx.beginPath();
              ctx.arc(rand() * W, rand() * H, 40 + rand() * 100, 0, Math.PI * 2);
              ctx.stroke();
          }
      }
      
      ctx.filter = 'none'; // Reset filter
      ctx.globalCompositeOperation = 'source-over'; // Reset blend mode
      ctx.globalAlpha = 1.0;
  }
  
  // --- UNIQUE STYLE: Field Tracer (Simplified Particle Flow) ---
  function paintFieldTracer(colors, rand) {
      paintBackdrop();
      const W = canvas.width, H = canvas.height;
      const numLines = 500;
      const step = 20;

      ctx.lineWidth = 0.5;
      ctx.globalAlpha = 0.08;

      for (let i = 0; i < numLines; i++) {
          const color = colors[Math.floor(rand() * colors.length)];
          ctx.strokeStyle = color;

          let x = rand() * W;
          let y = rand() * H;

          ctx.beginPath();
          ctx.moveTo(x, y);

          for (let j = 0; j < 50; j++) {
              // Field direction based on position, creates swirling flow
              const angle = Math.sin(x / 400 * Math.PI) * 2 + Math.cos(y / 300 * Math.PI) * 3 + rand() * 0.5;
              const nextX = x + Math.cos(angle) * step * (0.5 + rand() * 0.5);
              const nextY = y + Math.sin(angle) * step * (0.5 + rand() * 0.5);

              // Stop if particle goes off screen
              if (nextX < 0 || nextX > W || nextY < 0 || nextY > H) break;

              ctx.lineTo(nextX, nextY);
              x = nextX;
              y = nextY;
          }
          ctx.stroke();
      }
      ctx.globalAlpha = 1.0;
  }

  // --- UNIQUE STYLE: Recursive Fractal Growth (Tree) ---
  function paintRecursiveFractalGrowth(colors, rand) {
      const W = canvas.width, H = canvas.height;
      ctx.fillStyle = colors[0]; // Darkest color for background
      ctx.fillRect(0, 0, W, H);
      
      const drawBranch = (x, y, length, angle, depth) => {
          // If we run out of colors, just use the last one
          const colorIndex = Math.min(depth, colors.length - 1);
          
          const endX = x + length * Math.cos(angle);
          const endY = y + length * Math.sin(angle);

          const color = colors[colorIndex];
          ctx.strokeStyle = color;
          // Thicker lines for deeper/starting branches
          ctx.lineWidth = (colors.length - colorIndex) * 2; 
          ctx.globalAlpha = 0.5 + colorIndex * 0.1;

          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(endX, endY);
          ctx.stroke();

          if (colorIndex < colors.length - 1) {
              const newLength = length * (0.6 + rand() * 0.2);
              const branchAngle = Math.PI/4 * (0.5 + rand() * 0.5); // Randomize angle spread

              // Draw left branch
              drawBranch(endX, endY, newLength, angle - branchAngle, depth + 1);
              // Draw right branch
              drawBranch(endX, endY, newLength, angle + branchAngle, depth + 1);
          }
      }
      
      // Start the fractal from the bottom center
      const startLength = H * 0.3;
      drawBranch(W/2, H, startLength, -Math.PI/2, 1);
      
      ctx.globalAlpha = 1.0;
  }

  // --- UNIQUE STYLE: Woven Tessellation (Interlocking Pattern) ---
  function paintWovenTessellation(colors, rand) {
      const W = canvas.width, H = canvas.height;
      const step = 80 + rand() * 40;
      const stripWidth = 20 + rand() * 15;
      
      ctx.fillStyle = colors[0]; // Background
      ctx.fillRect(0, 0, W, H);

      const colorH = colors[1];
      const colorV = colors[2] || colors[4]; // Use an alternate color if only 2 exist

      // Function to draw a continuous strip
      const drawStrip = (x, y, horizontal, color) => {
          ctx.fillStyle = color;
          ctx.globalAlpha = 0.9;
          if (horizontal) {
              ctx.fillRect(0, y - stripWidth / 2, W, stripWidth);
          } else {
              ctx.fillRect(x - stripWidth / 2, 0, stripWidth, H);
          }
      }

      // 1. Draw all horizontal strips (The "under" layer)
      for (let y = step / 2; y < H + step; y += step) {
          drawStrip(0, y, true, colorH);
      }

      // 2. Draw all vertical strips (The "over" layer initially)
      for (let x = step / 2; x < W + step; x += step) {
          drawStrip(x, 0, false, colorV);
      }

      // 3. Create the 'over-under' illusion at intersections using destination-out
      ctx.globalCompositeOperation = 'destination-out';
      ctx.globalAlpha = 1.0; 

      // Erase a section of the vertical strip where it should pass "under"
      for (let x = step / 2; x < W + step; x += step) {
          for (let y = step / 2; y < H + step; y += step) {
              // Alternate which strip is on top to create the weave pattern
              if ((Math.floor(x / step) + Math.floor(y / step)) % 2 === 0) {
                  // Erase the vertical strip section
                  ctx.fillRect(x - stripWidth / 2, y - stripWidth / 2, stripWidth, stripWidth);
              }
          }
      }
      
      ctx.globalCompositeOperation = 'source-over';
      
      // 4. Draw the "under" color back into the erased parts to complete the weave
      ctx.globalCompositeOperation = 'destination-over';
      for (let x = step / 2; x < W + step; x += step) {
          for (let y = step / 2; y < H + step; y += step) {
              if ((Math.floor(x / step) + Math.floor(y / step)) % 2 === 0) {
                  // Fill the gap with the horizontal strip color (which should be "under")
                  ctx.fillStyle = colorH; 
                  ctx.fillRect(x - stripWidth / 2, y - stripWidth / 2, stripWidth, stripWidth);
              }
          }
      }

      ctx.globalCompositeOperation = 'source-over';
      ctx.globalAlpha = 1.0;
  }

  function addGrainOverlay(strength = 0.08, rand){
    const W = Math.ceil(canvas.width/2), H = Math.ceil(canvas.height/2);
    const n = document.createElement('canvas');
    n.width = W; n.height = H;
    const nctx = n.getContext('2d');
    const img = nctx.createImageData(W, H);
    for (let i=0; i<img.data.length; i+=4){
      const v = 128 + Math.floor((rand()*2-1) * 255 * strength);
      img.data[i] = img.data[i+1] = img.data[i+2] = v;
      img.data[i+3] = 32;
    }
    nctx.putImageData(img, 0, 0);
    ctx.save();
    ctx.globalCompositeOperation = 'overlay';
    ctx.imageSmoothingEnabled = true;
    ctx.drawImage(n, 0,0, W,H, 0,0, canvas.width, canvas.height);
    ctx.restore();
  }

  function drawSignature(){
    const txt = 'Palette Collage';
    ctx.save();
    ctx.font = '12px ui-monospace, Menlo, Consolas, monospace';
    ctx.fillStyle = 'rgba(233,238,243,.7)';
    ctx.textAlign = 'right';
    ctx.fillText(txt, canvas.width - 14, canvas.height - 18);
    ctx.restore();
  }

  function drawPaletteBar(colors){
    paletteEl.innerHTML = '';
    colors.forEach(h => {
      const sw = document.createElement('div');
      sw.className = 'swatch';
      sw.style.background = h;
      const span = document.createElement('span');
      span.textContent = h.toUpperCase();
      // Ensure legible text color
      const [r,g,b] = hexToRgb(h);
      const luminance = 0.299*r + 0.587*g + 0.114*b;
      span.style.color = luminance > 140 ? '#0b0f15' : '#e9eef3';
      sw.appendChild(span);
      paletteEl.appendChild(sw);
    });
  }

  // ---- I/O: open, drop, paste ---------------------------------------------

  function requestFilePicker(){
    fileInput.value = '';
    fileInput.click();
  }

  async function handleFile(file){
    if (!file || !file.type.startsWith('image/')) {
      showToast('Please choose an image file.'); return;
    }
    const blob = await file.arrayBuffer();
    const bmp = await createImageBitmap(new Blob([blob]));
    currentImageBitmap = bmp;
    currentPalette = await extractPaletteFromImageBitmap(bmp, 5, 80, 10);
    rngSeed = Math.random()*1e9;
    repaint();
    showToast('Generated new artwork ✨');
  }

  async function handleClipboardPaste(e){
    const items = e.clipboardData?.items || [];
    for (const it of items){
      if (it.type && it.type.startsWith('image/')){
        const file = it.getAsFile();
        if (file) { await handleFile(file); return; }
      }
    }
    showToast('Paste an image from your clipboard.');
  }

  async function handleDrop(e){
    e.preventDefault();
    overlay.classList.remove('show');
    const file = e.dataTransfer.files?.[0];
    if (file) await handleFile(file);
  }

  // ---- Actions -------------------------------------------------------------

  function shuffle(){
    rngSeed = Math.random()*1e9;
    repaint();
  }

  function exportPNG(){
    const url = canvas.toDataURL('image/png');
    const a = document.createElement('a');
    a.href = url;
    const stamp = new Date().toISOString().replace(/[:.]/g,'-');
    a.download = `palette-collage-${stamp}.png`;
    a.click();
    showToast('Exported PNG');
  }

  async function copyPalette(){
    try {
      await navigator.clipboard.writeText(currentPalette.map(h=>h.toUpperCase()).join(' '));
      copyBtn.classList.add('glow');
      setTimeout(()=>copyBtn.classList.remove('glow'), 350);
      showToast('Copied HEX palette');
    } catch {
      showToast('Copy failed — permission denied');
    }
  }

  // ---- Events --------------------------------------------------------------

  openBtn.addEventListener('click', requestFilePicker);
  fileInput.addEventListener('change', (e)=> handleFile(e.target.files?.[0]));
  shuffleBtn.addEventListener('click', shuffle);
  exportBtn.addEventListener('click', exportPNG);
  copyBtn.addEventListener('click', copyPalette);
  modeSel.addEventListener('change', repaint);

  window.addEventListener('dragover', (e)=> { e.preventDefault(); overlay.classList.add('show'); }, false);
  window.addEventListener('dragleave', ()=> overlay.classList.remove('show'), false);
  window.addEventListener('drop', handleDrop, false);
  window.addEventListener('paste', handleClipboardPaste);

  window.addEventListener('keydown', (e)=>{
    if (e.code === 'Space'){ e.preventDefault(); shuffle(); }
    if (e.key === '1'){ modeSel.value = 'blobs'; repaint(); }
    if (e.key === '2'){ modeSel.value = 'shards'; repaint(); }
    if (e.key === '3'){ modeSel.value = 'stripes'; repaint(); }
    if (e.key === '4'){ modeSel.value = 'bauhaus'; repaint(); } 
    if (e.key === '5'){ modeSel.value = 'diagonal'; repaint(); } 
    // Standard Mode Shortcuts
    if (e.key === '6'){ modeSel.value = 'pixel'; repaint(); } 
    if (e.key === '7'){ modeSel.value = 'contour'; repaint(); } 
    if (e.key === '8'){ modeSel.value = 'glass'; repaint(); } 
    if (e.key === '9'){ modeSel.value = 'wave'; repaint(); } 
    if (e.key === '0'){ modeSel.value = 'halftone'; repaint(); }
    if (e.key.toLowerCase() === 'q'){ modeSel.value = 'rectilinear'; repaint(); }
    if (e.key.toLowerCase() === 'w'){ modeSel.value = 'neon'; repaint(); }
    // Unique Mode Shortcuts
    if (e.key.toLowerCase() === 'r'){ modeSel.value = 'tracer'; repaint(); }
    if (e.key.toLowerCase() === 't'){ modeSel.value = 'fractal'; repaint(); }
    if (e.key.toLowerCase() === 'y'){ modeSel.value = 'woven'; repaint(); }
    
    if (e.key.toLowerCase() === 'e'){ exportPNG(); }
    if (e.key.toLowerCase() === 'c'){ copyPalette(); }
    if (e.key.toLowerCase() === 'o'){ requestFilePicker(); }
  });

  // Initial paint
  repaint();
})();
</script>
</body>
</html>